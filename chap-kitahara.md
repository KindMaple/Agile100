# 90％シンドロームを患っていたチームが、どうやって回復したか

<div class="flushright">kitahara</div>

## 何が起きていた？
とあるチームが１週間スプリントでスクラム開発を行なっていたのですが、
スプリント終了時点で、Doingのアイテムが複数残っていることが常態化していました。

ある日のスプリントレビューの風景

Dev「ほぼほぼ開発できているので、90％ぐらいは終わっています。」

PO「デモ見せてもらえる？」

Dev「まだデモが見せられる状態ではありません。」

PO「。。。」


スクラムなのに、バックログアイテムも分解しているのに、、それでも90%シンドロームが起きてしまう。
**スクラムなのに90％シンドローム!**

常に進捗報告のプレッシャーを受けながら開発をしてきたプログラマの習性なのでしょうが、きちんと解決しないとなんちゃってアジャイルを邁進する事になってしまいます。

何よりもDoneにならない事を普通と思う空気感がチームに出来てしまっているので、根本的な部分から立て直しが必要そうです。

プロジェクト統括なる人にも状況を聞いてみたところ、やはり計画通りに進まなかったり、見通しが立てられない事に不満を感じていたのですが、具体的な改善策が見つからないまま、ずるずるとプロジェクトを進めていたようです。

そしてスクラムマスターからは「じゃあ残業を増やして稼働を上げましょう」なんていう意見が飛び出す始末で、早く手を打たないと本当にマズい状況です。

きちんとアウトプットできるチームへ立て直しをしないとみんな不幸になってしまいますし、
何よりプロジェクト失敗の原因をスクラムのせいにされてしまうのは見過ごせません。

ということで、スクラムマスター補佐（？）という役割で無理矢理チームに参画することとなりました。

以下で、私たちがどうやって安定したベロシティを出せるチームになったかをご紹介いたします。

※アウトプットじゃなくてアウトカムだろ！みたいな意見は最もなのですが、スクラムが機能していないのでまずは安定したベロシティでアウトプットできる事を目指しました。


## 原因を考えてみた

Doneにならない原因

1. ベロシティを生産性の目標値としていた

スプリントプランニング時には、チームのキャパシティよりも多めにスプリントバックログアイテムを積むように、PO、SMから指示されていたそうです。

当然、見積もりには下振れもあるので「全部Doneになって時間が余ったらもったいない」という思考ですね。

気持ちは分からなくもないですが、リソース効率だけにフォーカスした結果、全てのアイテムがDoneにならなくても当たり前の状況を自ずから作り出してしまっていました。


2. 割り込み作業が多い

サービス開始前なので、業務が停止するような緊急事態は本来は発生しないはずです。

ですが、業務整理が並行で進んでいたため、調査やら他システム向けのテストデータ作成など、今日明日締め切りの作業依頼が頻繁に発生していました。

一つ一つの作業は軽微だったのですが、当然のことながら頻繁な割り込み作業は開発効率を大きく低下させます。


3. バックログアイテムのサイズが大き過ぎる

そもそものアイテムが十分に分解出来ていなそうです。

対象のプロダクトがAPI中心だったことも影響しているのですが、フロント周りの機能がほとんど無かったために〇〇APIを作成するといったアイテムが散見されました。

画面機能であれば、「〇〇ボタンを押下したら画面が遷移する」とか単純な動作をアイテムに切り分けるのもそれほど悩むこともなさそうですが、何せAPIだと切り分け方がよく分からない。これがアイテムが分解しにくい一因になっていそうです。



## 何をやったか
その１

まずは、キャパシティを超えるような計画を止めて、全てがDoneになる量で計画することにしました。

（プロジェクト管理者に認めてもらうまでには相当の戦いがありましたが、、）


その２

次にプロジェクト管理者やステークホルダーに根気強くスイッチングコストの説明を行い、割り込み作業は全て次のスプリント（翌週）まで待ってもらうようにしました。

（プロジェクト管理者に認めてもらうまでには相当の戦いがありましたが、、）


その３

そして、バックログアイテムをより小さく分解することに取り組むのですが、外的な阻害要因よりも、むしろ一番苦労した問題でした。

ここからはアイテム分解の話しを中心にしたいと思います。

REST API開発する場合、どうやって分解すれば良いのか？

従来型の開発であれば、

テーブル作成して、データオブジェクトなりアクセサーなり作って、呼び出し処理を作って、メイン作って、最後にAPI Gatewayで公開

こんな感じでしょうか。

でもこの通りに作って行くとエンドツーエンドになりません。

スプリントレビューで「テーブルが出来ました」とか「〇〇共通部品が出来ました」と言われても、プロダクトオーナーも困惑するでしょう。

プログラマーが機能を分解しようとするとコンポーネント指向で水平分割してしまいがちですが、理想を言うとアイテムの分解においてはエンドツーエンドの垂直分割にして、その配下のタスクはコンポーネントに分解したいわけです。

言うのは簡単ですが、概念を理解すれば実践できるほど簡単なものでもありません。
実際にアイテムを垂直分割で小さく分解できるようになるまでにはチーム全員で頭を悩ませながら取り組んでいきました。

### どうやってエンドツーエンドになるように分解したのか

「フロント（に近い）側、つまりエンドポイントから開発をする」を基本方針としました。

従来の開発順序だとデータベース側、つまりフロントから遠い側からレイヤーを積み重ねるような進め方をしていたものを

これまでとは逆側から作り始めようなんて言いだしたのだから、当然開発メンバーから反発されました。

「プログラム分かってないヤツが何か変な事言い出したぞ」といった様子で大ブーイングです。

そこで簡単な例を挙げて、「こんな感じで一回作ってみましょう。今週の開発進捗が大幅に下がったら、来週は元のやり方に戻せば良いだけなので気にしないでください。プロダクトオーナーには私が変なやり方を押し付けたせいだと言ってもらって構いません。」と言ったところ、

「そこまで言うなら一度やってみよう」開発メンバーは受け入れてくれました。
<br>
<br>

>**基本方針（抜粋）**
>* バックログアイテム（ストーリー）は、エンドツーエンドで動作する単位で分ける
>* ○○ファンクションの作成等のコンポーネントで分割しない
>* アイテム（ストーリー）は、半日〜1日で完了するサイズを目安にする。
>* 実際に使用するストーリーポイントは1～3pt程度
>* それ以上のサイズは分割を検討する
>* 可能な限り1Ptに揃えるのが理想
>* 複雑なロジックが必要な場合は分割を検討する
>* 基本フローだけ先に作成して、機能をアドインする
>
>* 前提条件
>	* 操作、実行トリガー
>	* インターフェース仕様
>	* データ取得元、格納先
><br>
>* 受け入れ基準（Acceptance Criteria）は、ユーザーが確認できる事柄を記>載する
>	* 期待する結果
>	* アウトプットは成果物デモが出来るもの
>	* 受け入れ基準には、やらないこと（実装しないもの）を書いても良い
>	* エラーハンドリング、リトライ機能等を別アイテムに切り出す場合
><br>
><br>
>* 例）RESTful APIのGETの場合
>	1. エンドポイントURLへリクエスト送信→200が返る（パラメータなし、または受け捨て）
>	2. GETが投げられたら、該当テーブルを参照してレコードを1件返す（テーブルを参照出来ていることが確認できれば返す値は何でも良い）
>	3. GETパラメータにユニークキーを一つ指定して、該当レコードが正常に取得できる
>	4. GETパラメータを複数指定して、該当レコードが正常に取得できる（入力IFの実装）
>	5. 複数レコードが正常に取得できる
>	6. 参照結果を出力IFに合わせて返却する

<br>

やってみると最初はアイテムを分割するのに戸惑ってかなり時間を使いましたが、いざ実装の段になるとすぐに変化が見え始めました。

デイリースクラムで日々タスクが完了していくのが見えるようになると、明らかにリズムが良くなっている事が見てとれました。

開発メンバーも、すぐに終わりが見える状態で作業できるのでつまづく事が減って、開発ペースが上がったと実感できたと言っていました。

ここまで来れば、上手く機能し始めたと思えそうですが、まだ大きな問題が残っていました。

Readyになっているバックログアイテムがすぐに枯渇してしまう。

バックログリファイメントを週に1時間しかやっていなかったので、絶対的に不足していました。

POは社内のさまざまな会議に追われて、4時間（スプリントの10％）なんてまとまった時間は取れません。



### リファイメントの時間をどう確保したか
デイリー後にやった話を書く


### まとめ
スクラムで定義されているイベントは相互に作用するから、リファイメントしっかりやらないとプランニングもレビューもできない
上手くいかない時こそちゃんとスクラムガイドに忠実であるか見直すのは大事

